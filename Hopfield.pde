//どのパターンを記憶させるか　配列の最初から順に記憶していく
int pattern [] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
//何パターン記憶するか
int pat_num =2;
//どのパターンに近い入力を与えるか
int pat =0;

//ニューロンの重み
int w[][] = new int [63][63];
//ニューロンの状態
int x[]   = new int [63];

//０～９までの入力を配列で作成する
int[] zero = {  0, 0, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, 0, 0};


int[] one = {  0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, +1, 0, 0, 0, 
  0, 0, +1, +1, 0, 0, 0, 
  0, 0, 0, +1, 0, 0, 0, 
  0, 0, 0, +1, 0, 0, 0, 
  0, 0, 0, +1, 0, 0, 0, 
  0, 0, 0, +1, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, 0, 0};

int[] two = {  0, 0, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, 0, 0};


int[] three = {  0, 0, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, 0, 0, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, 0, 0};


int[] four = { 0, 0, 0, 0, 0, 0, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, +1, 0, +1, 0, 0, 0, 
  0, +1, +1, +1, +1, 0, 0, 
  0, 0, 0, +1, 0, 0, 0, 
  0, 0, 0, +1, 0, 0, 0, 
  0, 0, 0, +1, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0};


int[] five = { 0, 0, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, 0, 0};


int[] six = { 0, 0, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, 0, 0};


int[] seven = { 0, 0, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, 0, 0, 0, +1, 0, 0, 
  0, 0, 0, +1, 0, 0, 0, 
  0, 0, +1, 0, 0, 0, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, +1, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0};


int[] eight = { 0, 0, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, 0, 0};


int[] nine = { 0, 0, 0, 0, 0, 0, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, 0, 0, 0, +1, 0, 
  0, +1, +1, +1, +1, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, 0, 0, 0, 0, +1, 0, 
  0, 0, 0, 0, 0, 0, 0};

//作成した配列の値を参照する関数
//引数は、参照する数字の配列、その配列の何番目か
int get_number(int pat, int a) {
  switch(pat) {
  case 0:
    return zero[a];
  case 1:
    return one[a];
  case 2:
    return two[a];
  case 3:
    return three[a];
  case 4:
    return four[a];
  case 5:
    return five[a];
  case 6:
    return six[a];
  case 7:
    return seven[a];
  case 8:
    return eight[a];
  case 9:
    return nine[a];
  }
  return -1;
}

//ニューロンの状態に指定した配列をコピーする   
//引数はどれをニューロンの状態にするか、確率何％で変化させるか
void test_number(float p) {
  switch(pat) {
    //cloneを使うことでxが変化したとき他の配列が変化しないようにする
  case 0: 
    x=zero.clone();   
    break;
  case 1: 
    x=one.clone();    
    break;
  case 2: 
    x=two.clone();    
    break;
  case 3: 
    x=three.clone();  
    break;
  case 4: 
    x=four.clone();   
    break;
  case 5: 
    x=five.clone();   
    break;
  case 6: 
    x=six.clone();    
    break;
  case 7: 
    x=seven.clone();  
    break;
  case 8: 
    x=eight.clone();  
    break;
  case 9: 
    x=nine.clone();   
    break;
  }
  int i, j;
  //確率pだけニューロンを変化させる
  for (j=0; j<9; j++) {
    for (i=0; i<7; i++) {
      if (random(100)>(1-p)*100)
        //ニューロンの状態を0を1に、1を0に変える
        x[i+j*7]=1-x[i+j*7];
    }
  }
}

//自己早期的な連想記憶を近似的に行う
void remember_number() {
  int i, j, alpha;
  for (j=0; j<63; j++) {
    for (i=0; i<63; i++) {
      w[i][j]=0;
      //wij = 0
      if (i==j) {
        w[i][j]=0;
      } else {
        //wij = Σ(2Si-1)(2Sj-1)のような式の計算
        for (alpha=0; alpha<pat_num; alpha++) {
          w[i][j]=w[i][j]+(2*get_number(pattern[alpha], i)-1)*(2*get_number(pattern[alpha], j)-1);
        }
      }
    }
  }
}

//非同期的状態変化
void hopfield() {
  //ランダムに１つのニューロンを選ぶ
  int i=(int)random(63), j;
  int y=0;
  //y=Σwijxjのような式を計算する
  for (j=0; j<63; j++) {
    y=y+w[i][j]*x[j];
  }
  //y>0ならばxi(t+1)=1
  if (y>0) {
    x[i]=1;
    //y<0ならばxi(t+1)=0
  } else if (y<0) {
    x[i]=0;
  }
}

int time=0, error=0;

//現在のニューロンが記憶させたパターンを同じか調べる
//同じ場合は、入力を変化させたり、他のパターンを記憶させる
void correct() {
  //記憶させたパターンと同じものがないか調べる
  for (int i=0; i<pat_num; i++) {
    //correctはニューロンの状態と記憶させたパターンがどれぐらい違うか数値化するもの
    //完全一致でcorrect=0になる　一致しない場合はcorrect>0になる
    int correct=0;
    //ニューロンの状態と記憶させたパターンがどれぐらい違うか数値化する
    for (int a=0; a<63; a++) {
      //ニューロンの状態と記憶させたパターンが違う場合1加算される
      correct=correct+abs(x[a]-get_number(pattern[i], a));
    }
    //強制的にcorrectを0にして、次の試行に移る
    //読み出しが正常に行われず、かつ変化しない状態に陥った時に行う
    if (time>1000) {
      error++;
      saveFrame("C:/Users/b1014126/Desktop/Hopfield/error/error"+str(error)+".png");
      correct=0;
      i=100+error;
    }
    //correctが0で、試行するものがあるとき実行
    if (correct==0) {
      //記憶させたパターンと同じときその結果を出す
      //どのパターンを入力して、どれだけのパターンを記録させ、どのパターンと一致したか
      /*例えば以下のように表示される
       0 , 2 , 0
       1 , 2 , 1
       0 , 3 , 0
       1 , 3 , 1
       2 , 3 , 0
       0 , 4 , 0
       1 , 4 , 1
       2 , 4 , 100
       3 , 4 , 100
       0 , 5 , 0
       1 , 5 , 1
       */
      if (pat<9) {
        println(pat, ",", pat_num, ",", i);
        //記憶させたパターンをすべて試行したとき、他のパターンを記憶し、最初から試行する
        if (pat_num==pat+1) {
          pat_num++;
          pat=0;
          //記憶させたパターンをすべて試行していないとき、次の入力に変更する
        } else {
          pat++;
        }
        time=0;
        //パターン数に応じて連想記憶する
        remember_number();
        //入力を確率pで変化させる
        test_number(0.05);
      }
    }
  }
  time++;
}


int []not_w = new int [63];
void not_work() {
  int k=0;
  while (true) {
    k=(int)random(63);
    if (not_w[k]==0)break;
  } 
  for (int j=0; j<63; j++) {
    not_w[k]=1;
    w[k][j]=0;
    w[j][k]=0;
  }
}

int not=0;
void correct2() {
  //correctはニューロンの状態と記憶させたパターンがどれぐらい違うか数値化するもの
  //完全一致でcorrect=0になる　一致しない場合はcorrect>0になる
  int correct=0;
  //ニューロンの状態と記憶させたパターンがどれぐらい違うか数値化する
  for (int a=0; a<63; a++) {
    //ニューロンの状態と記憶させたパターンが違う場合1加算される
    if (not_w[a]!=1)
      correct=correct+abs(x[a]-get_number(pattern[pat], a));
  }
  //強制的にcorrectを0にして、次の試行に移る
  //読み出しが正常に行われず、かつ変化しない状態に陥った時に行う
  if (mousePressed) {
    correct=0;
    delay(1000);
  }
  //correctが0で、試行するものがあるとき実行
  if (correct==0) {
    //記憶させたパターンをすべて試行したとき、他のパターンを記憶し、最初から試行する
    if (pat==1) {
      pat=0;
      not++;
      //記憶させたパターンをすべて試行していないとき、次の入力に変更する
    } else {
      pat=1;
    }
    //パターン数に応じて連想記憶する
    not_work();
    println(not, pat);
    //入力を確率pで変化させる
    test_number(0.05);
  }
}


void setup() {
  //size(350,450);
  size(1700, 700);
  //パターン数に応じて連想記憶する
  remember_number();
  //入力を確率pで変化させる
  test_number(0.05);
}

void draw() {
  //ランダムにニューロンを選び、規則に従って変化させる
  hopfield();
  int i, j;
  background(0);
  //ニューロンの状態を表示する
  for (j=0; j<9; j++) {
    for (i=0; i<7; i++) {
      //ニューロンの状態が1なら赤、0なら白
      if (x[i+j*7]==1)
        fill(255, 0, 0);
      else
        fill(255);
      //画面上に7*9の丸で表現する
      ellipse(50*i+25, 50*j+25, 50, 50);
      fill(0);
      //テキストでどのニューロンか視覚化
      text(i+j*7, 50*i+20, 50*j+25);
    }
  }


  fill(255);
  //それぞれの重みを表示するときの背景
  rect(350, 0, width, height);
  textSize(10);
  for (j=0; j<63; j++) {
    fill(0);
    //どのニューロンか表記
    text(j, 350+j*20, 20);
    for (i=0; i<63; i++) {
      //動作しないニューロンか判断　動作しないなら赤　動作するなら黒
      if (not_w[i]==1 || not_w[j]==1)
        fill(255, 0, 0);
      else
        fill(0);
      text(w[i][j], 350+i*20, 50+j*20);
    }
  }  

  //ニューロンの状態が記憶させたパターンと同じなら次の試行に移る
  //課題1ならtrue、課題2ならfalse
  /*
  if(false)
    correct();
  else
    correct2();
  */
  
  if (mousePressed) {
    fill(0);
    text(time, mouseX, mouseY);
  }
}